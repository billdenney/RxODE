# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Check the type of an object using Rcpp
#'
#' @param obj Object to check
#' @param cls Type of class.  Only s3 classes and primitive classes are checked.
#'    For matrix types they are distinguished as \code{numeric.matrix}, \code{integer.matrix},
#'    \code{logical.matrix}, and \code{character.matrix} as well as the traditional \code{matrix}
#'    class.
#'
#' @return A boolean indicating if the object is a member of the class.
#' @keywords internal
#' @export
rxIs <- function(obj, cls) {
    .Call(`_RxODE_rxIs`, obj, cls)
}

#' Setup a data frame for solving multiple subjects at once in RxODE.
#'
#' @param df dataframe to setup; Must be in RxODE compatible format.
#' @param covNames Covariate names in dataset.
#' @param amountUnits Dosing amount units.
#' @param timeUnits Time units.
#'
#' @return A data structure to allow C-based for loop (ie solving each
#'       individual in C)
#'
#' @export
rxDataSetup <- function(df, covNames = NULL, amountUnits = "NA", timeUnits = "hours") {
    .Call(`_RxODE_rxDataSetup`, df, covNames, amountUnits, timeUnits)
}

rxEventTableExpand <- function(nsub, df, amountUnits = "NA", timeUnits = "hours", expandData = FALSE) {
    .Call(`_RxODE_rxEventTableExpand`, nsub, df, amountUnits, timeUnits, expandData)
}

#' Invert matrix using Rcpp Armadilo.  
#'
#' @param matrix matrix to be inverted.
#' @return inverse or pseudo inverse of matrix.
#' @export
rxInv <- function(matrix) {
    .Call(`_RxODE_rxInv`, matrix)
}

rxToOmega <- function(cholMat) {
    .Call(`_RxODE_rxToOmega`, cholMat)
}

#' Get Omega^-1 and derivatives
#'
#' @param invObjOrMatrix Object for inverse-type calculations.  If this is a matrix,
#'     setup the object for inversion by \code{\link{rxSymInvCholCreate}} with the default arguments and return
#'     a reactive s3 object.  Otherwise, use the inversion object to calculate the requested derivative/inverse.
#' @param theta Thetas to be used for calculation.  If missing (\code{NULL}), a
#'     special s3 class is created and returned to access Omega^1
#'     objects as needed and cache them based on the theta that is
#'     used.
#' @param type The type of object.  Currently the following types are
#'     supported:
#' \itemize{
#' \item \code{cholOmegaInv} gives the
#'     Cholesky decomposition of the Omega Inverse matrix.
#' \item \code{omegaInv} gives the Omega Inverse matrix.
#' \item \code{d(omegaInv)} gives the d(Omega^-1) withe respect to the
#'     theta parameter specified in \code{theta.number}.
#' \item \code{d(D)} gives the d(diagonal(Omega^-1)) with respect to
#'     the theta parameter specified in the \code{theta.number}
#'     parameter
#' }
#' @param theta.number For types \code{d(omegaInv)} and \code{d(D)},
#'     the theta number that the derivative is taken against.  This
#'     must be positive from 1 to the number of thetas defining the
#'     Omega matrix.
#' @return Matrix based on parameters or environment with all the
#'     matrixes calculated in variables omega, omegaInv, dOmega,
#'     dOmegaInv.
#' @author Matthew L. Fidler
#' @export
rxSymInvChol <- function(invObjOrMarix, theta = NULL, type = "cholOmegaInv", thetaNumber = 0L) {
    .Call(`_RxODE_rxSymInvChol`, invObjOrMarix, theta, type, thetaNumber)
}

rxSymInvCholEnvCalculate <- function(obj, what, theta = NULL) {
    .Call(`_RxODE_rxSymInvCholEnvCalculate`, obj, what, theta)
}

#' Calculate Wishart Variance based on Omega matrix
#'
#' @param Omega is the square positive definite matrix
#' @param nu is the degrees of freedom of the Wishart Distribution.
#' @return Variance matrix
#' @export
rxInvWishartVar <- function(Omega, nu) {
    .Call(`_RxODE_rxInvWishartVar`, Omega, nu)
}

RxODE_finalize_focei_omega <- function(rho) {
    invisible(.Call(`_RxODE_RxODE_finalize_focei_omega`, rho))
}

RxODE_finalize_log_det_OMGAinv_5 <- function(rho) {
    .Call(`_RxODE_RxODE_finalize_log_det_OMGAinv_5`, rho)
}

#' Echo cout to console for a number
#'
#' @param number number to output
#'
#'  @return nothing.
#'
#' @export
rxCoutEcho <- function(number) {
    invisible(.Call(`_RxODE_rxCoutEcho`, number))
}

removableDrive <- function(driveRoot) {
    .Call(`_RxODE_removableDrive`, driveRoot)
}

